from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
import json
import random
import time
from datetime import datetime


# === WhatsApp SETUP ===
WHATSAPP_TARGET = '"IntelliTrade"'  # ← group or contact name
CHROME_PROFILE_PATH = "user-data-dir=C:/Users/Aman/AppData/Local/Google/Chrome/User Data"
CHROMEDRIVER_PATH = "D:/chromedriver.exe"

def setup_whatsapp():
    options = webdriver.ChromeOptions()
    options.add_experimental_option("excludeSwitches", ["enable-logging"])
    options.add_argument(CHROME_PROFILE_PATH)
    driver = webdriver.Chrome(CHROMEDRIVER_PATH, chrome_options=options)
    driver.get("https://web.whatsapp.com/")
    wait = WebDriverWait(driver, 100)
    return driver, wait

def send_whatsapp_message(driver, wait, target, message):
    x_arg = f'//span[contains(@title, {target})]'
    try:
        group_title = wait.until(EC.presence_of_element_located((By.XPATH, x_arg)))
        group_title.click()
        inp_xpath = '//*[@id="main"]/footer/div[1]/div/span[2]/div/div[2]/div[1]/div/div[1]'
        input_box = wait.until(EC.presence_of_element_located((By.XPATH, inp_xpath)))
        for line in message.strip().split('\n'):
            input_box.send_keys(line + Keys.SHIFT + Keys.ENTER)
        input_box.send_keys(Keys.ENTER)
    except Exception as e:
        print(f"Failed to send message: {e}")

# === CONFIG ===
MT5_PATH = r"C:/Program Files/MetaTrader 5 Terminal/terminal64.exe"  # adjust for Deriv or Official
TIMEFRAME = mt5.TIMEFRAME_M30
DONCHIAN_PERIOD = 20
MACD_FAST, MACD_SLOW, MACD_SIGNAL = 12, 26, 9
FIB_LEVELS = [100, 161.8, 261.8, 423.6]  # TP1→TP4 in inverted fib %
RR = 3  # Risk:Reward
TRACK_FILE = "intellitrade_trades.json"

REASONS = [
    "Reactive zone interaction aligned with macro flow indicator.",
    "Price-action trigger supported by momentum divergence resolution.",
    "Structural inflection respected with oscillator confirmation.",
    "Dynamic range boundary interaction with trend alignment.",
    "Volatility compression followed by directional momentum shift.",
    "Liquidity zone engagement validated by momentum oscillator.",
    "Trend filter confirmation at key market structure pivot.",
    "Momentum oscillator crossover at critical price threshold.",
    "Price structure test coupled with internal momentum validation.",
    "Algorithmic trigger from volatility cluster and flow alignment."
]

# === TRACKING ===
def load_trades():
    try:
        return json.load(open(TRACK_FILE))
    except:
        return {}

def save_trades(trades):
    json.dump(trades, open(TRACK_FILE, "w"), indent=4)

def gen_id(sym): return f"{sym}_{datetime.now().strftime('%Y%m%d%H%M%S')}"

# === INDICATORS ===
def get_macd_sig_hist(df):
    macd = df['close'].ewm(span=MACD_FAST, adjust=False).mean() - df['close'].ewm(span=MACD_SLOW, adjust=False).mean()
    sig = macd.ewm(span=MACD_SIGNAL, adjust=False).mean()
    return macd, sig, macd - sig

def get_donchian(df):
    up = df['high'].rolling(DONCHIAN_PERIOD).max()
    low = df['low'].rolling(DONCHIAN_PERIOD).min()
    return up, low

def calc_tps_sl(entry, direction):
    tps = []
    for lvl in FIB_LEVELS:
        if direction == "BUY":
            tps.append(round(entry + entry * lvl/100, 5))
        else:
            tps.append(round(entry - entry * lvl/100, 5))
    sl = round(tps[0] - (abs(tps[0] - entry) * RR) * (1 if direction=="SELL" else -1), 5)
    return tps + [sl]

def build_msg(sym, dir, entry, tps, sl, tid, confidence, timeframe="M1"):
    # Format timestamps
    time_str = datetime.now().strftime('%Y-%m-%d %H:%M')

    # Build TP lines with arrow and consistent formatting
    tp_lines = "\n".join([f"🎯 TP{i+1} → {tp}" for i, tp in enumerate(tps)])

    # Sophisticated execution insight examples (can be randomized or refined)
    insights = [
        "⚙️ Momentum-phase crossover triggered at a historically reactive node with high confluence.",
        "⚙️ Price rejection at a dynamic range boundary accompanied by latent oscillator divergence.",
        "⚙️ Structural inflection validated by multi-timeframe trend alignment and volume spike.",
        "⚙️ Liquidity zone engagement confirmed with synchronized oscillator momentum shift.",
        "⚙️ Volatility compression phase resolved into directional breakout on confluence levels.",
        "⚙️ Algorithmic trigger generated by integrated flow model and momentum oscillator.",
        "📐 Structural pivot aligned with flow-pressure models and dynamic range theory.",
        "📊 Volatility compression breakout confirmed by trend-phase oscillator and execution flow signature.",
        "🔍 Rejection from adaptive supply zone with embedded divergence and liquidity sweep.",
        "⚙️ Momentum-phase crossover triggered at a historically reactive node with high confluence.",
        "🧭 Inertia reversal detected within volatility envelope, supported by multi-frame trend desync.",
        "🛰️ Algorithmic consensus identified directional bias via fractal liquidity mapping.",
        "🧠 Reactive price-action node confirmed by signal clustering and volatility alignment.",
        "💡 Confluence of orderbook inefficiency and macrostructural tension zone.",
        "📉 Liquidity vacuum met with impulse retracement at low-vol cluster boundary.",
        "📎 Temporal energy shift at volumetric inflection with reversal probability modeling."
    ]
    insight = random.choice(insights)

    return f"""
    📈 IntelliTrade Signal Alert  
    ━━━━━━━━━━━━━━━━━━━━━━━  
    🔹 Asset: {sym}  
    📥 Direction: {dir}  
    🕒 Time: {time_str}  
    ⏳ Timeframe: {timeframe}  
    🔋 Confidence: {confidence}%  

    💵 Entry: {entry}  
    {tp_lines}  
    🛑 Stop Loss: {sl}  
    🆔 Trade ID: {tid}  

    ━━━━━━━━━━━━━━━━━━━━━━━  
    📊 Execution Insight:  
    {insight}  
    ━━━━━━━━━━━━━━━━━━━━━━━  
    🚀 _Powered by IntelliTrade Alpha Engine_
    """
    ""

# === MT5 INIT ===
# === MT5 INIT ===
if not mt5.initialize(path=MT5_PATH):
    raise RuntimeError("Failed to init MT5")

tracked = load_trades()

while True:
    symbols = [s.name for s in mt5.symbols_get()]
    for sym in symbols:
        if sym in tracked and tracked[sym]['status'] == "open":
            continue  # skip if trade open

        print(f"[INFO] Fetching rates for symbol: {sym} ...")
        rates = mt5.copy_rates_from_pos(sym, TIMEFRAME, 0, DONCHIAN_PERIOD+50)
        if rates is None:
            print(f"[WARN] No rates returned for {sym}, skipping...")
            continue

        df = pd.DataFrame(rates)
        if df.empty or len(df) < DONCHIAN_PERIOD+5:
            print(f"[WARN] Insufficient data for {sym}, skipping...")
            continue

        df['time'] = pd.to_datetime(df['time'], unit='s')
        up, low = get_donchian(df)
        macd, sig, hist = get_macd_sig_hist(df)

        last = df['close'].iloc[-1]
        prev_hist = hist.iloc[-2]; prev_sig = sig.iloc[-2]
        curr_hist = hist.iloc[-1]; curr_sig = sig.iloc[-1]

        direction = None
        if last >= up.iloc[-2] and prev_hist > prev_sig and curr_hist < curr_sig:
            direction = "SELL"
        elif last <= low.iloc[-2] and prev_hist < prev_sig and curr_hist > curr_sig:
            direction = "BUY"

        if direction:
            price = mt5.symbol_info_tick(sym).bid if direction=="SELL" else mt5.symbol_info_tick(sym).ask
            tps_sl = calc_tps_sl(price, direction)
            tps, sl = tps_sl[:4], tps_sl[4]
            tid = gen_id(sym)
            msg = build_msg(sym, direction, price, tps, sl, tid)
            print(msg)  # replace with WhatsApp send
            tracked[sym] = {"id": tid, "symbol": sym, "dir": direction,
                             "entry": price, "tps": tps, "sl": sl,
                             "status": "open", "hit": []}

    # === MONITOR OPEN TRADES ===
    for sym, tr in tracked.items():
        if tr['status'] != "open": continue
        tick = mt5.symbol_info_tick(sym)
        price = tick.bid if tr['dir']=="SELL" else tick.ask

        for i, tp in enumerate(tr['tps']):
            if tp not in tr['hit'] and ((tr['dir']=="BUY" and price>=tp) or (tr['dir']=="SELL" and price<=tp)):
                tr['hit'].append(tp)
                print(f"✅ {sym} TP{i+1} hit @ {tp} – trade continues")
        if len(tr['hit']) >= 1:
            if ((tr['dir']=="BUY" and price <= tr['sl']) or (tr['dir']=="SELL" and price >= tr['sl'])):
                tr['status'] = "closed-sl"
                print(f"🛑 {sym} SL hit after TP – closing trade")
        if len(tr['hit']) >= 4:
            tr['status'] = "closed-tp4"
            print(f"🏁 {sym} TP4 reached – trade closed")

    save_trades(tracked)
    time.sleep(30)

    

mt5.shutdown()
